"use strict";(self.webpackChunkjson_logic_engine_documentation=self.webpackChunkjson_logic_engine_documentation||[]).push([[960],{1933:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"methods","title":"Adding Methods","description":"Adding Methods","source":"@site/docs/methods.md","sourceDirName":".","slug":"/methods","permalink":"/json-logic-engine/docs/methods","draft":false,"unlisted":false,"editUrl":"https://github.com/TotalTechGeek/json-logic-engine-documentation/edit/master/website/docs/methods.md","tags":[],"version":"current","frontMatter":{"id":"methods","title":"Adding Methods"},"sidebar":"someSidebar","previous":{"title":"Installation and Setup","permalink":"/json-logic-engine/docs/"},"next":{"title":"Asynchronous Engine","permalink":"/json-logic-engine/docs/async"}}');var s=t(4848),o=t(8453);const r={id:"methods",title:"Adding Methods"},a=void 0,l={},d=[{value:"Adding Methods",id:"adding-methods",level:2},{value:"Adding a whole library",id:"adding-a-whole-library",level:3},{value:"Additional Flexibility",id:"additional-flexibility",level:4},{value:"Assisting the Engine",id:"assisting-the-engine",level:4}];function c(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",hr:"hr",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"adding-methods",children:"Adding Methods"}),"\n",(0,s.jsx)(n.p,{children:"While the default methods support a lot of common functionality, to make the logic engine useful within your domain & give it the ability to interact with your platform, the module has tried to make it simple to add new commands into the framework."}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const engine = new LogicEngine()\n\nengine.addMethod('hello', ([name]) => {\n    return `Hello, ${name}!`\n})\n\nconst f = engine.build({ 'hello': {var: ''} })\n\nconsole.log(f('json-logic-engine')) // Hello, json-logic-engine!\n"})}),"\n",(0,s.jsx)(n.p,{children:"Let's use a less silly example,"}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.addMethod('repeat', ([str, times]) => {\n    return str.repeat(times)\n})\n\nconst g = engine.build({ 'cat' : [{ 'repeat': [{var: ''}, 7] }, ' Batman'] })\n\nconsole.log(g('Na')) // NaNaNaNaNaNaNa Batman\u2008\n"})}),"\n",(0,s.jsx)(n.h3,{id:"adding-a-whole-library",children:"Adding a whole library"}),"\n",(0,s.jsxs)(n.p,{children:["If you would like to import a whole library, you may call ",(0,s.jsx)(n.code,{children:"addModule"})," to do so."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// imports all of the methods from Math (the annotations are explained below, and can be left off. They can help optimize your logic though.)\nengine.addModule(\'Math\', Math, { deterministic: true, sync: true })\n\nconst j = engine.build({ "Math.sqrt": { "Math.round": 25.3 } })\n\nconsole.log(j()) //? prints 5\n'})}),"\n",(0,s.jsx)(n.h4,{id:"additional-flexibility",children:"Additional Flexibility"}),"\n",(0,s.jsx)(n.p,{children:"This section is only for really niche edge cases, I don't expect it to benefit most users."}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsx)(n.p,{children:"If you need more capability than executing a function, like hijacking the traversal of the input or accessing context, it is possible to do so."}),"\n",(0,s.jsxs)(n.p,{children:["You can disable the automatic traversal of the input by using ",(0,s.jsx)(n.code,{children:"traverse: false"}),", this can be useful if you want to preserve the input for things like defining your own control structures."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'engine.addMethod(\'repeatObj\', {\n   traverse: false,\n   method: ([obj, times]) => {\n       return JSON.stringify(obj).repeat(times)\n   }\n})\n\nconst h = engine.build({ \'repeatObj\': [{ var: \'a\' }, 5] })\n\nconsole.log(h()) // prints "{"var":"a"}{"var":"a"}{"var":"a"}{"var":"a"}{"var":"a"}"\n'})}),"\n",(0,s.jsxs)(n.p,{children:["You can also specify an alternate ",(0,s.jsx)(n.code,{children:"asyncMethod"})," in case for whatever reason a particular function would not function the same in an asynchronous environment (like if you're making calls to ",(0,s.jsx)(n.code,{children:"engine.run"}),")."]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)(n.p,{children:["Your method can have the following signature:\n",(0,s.jsx)(n.code,{children:"(input, context, above, engine) => {}"})]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Params"}),(0,s.jsx)(n.th,{children:"Explanation"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"input"}),(0,s.jsx)(n.td,{children:"Whatever data is passed into the function. If traversal is disabled, this'll be the raw input."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"context"}),(0,s.jsx)(n.td,{children:'The current "context" for the run-time. This can be either whatever the function is invoked with, or the context set by a higher order operator (map, reduce, etc.)'})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"above"}),(0,s.jsx)(n.td,{children:"Whenever a higher order operator is invoked, it pushes the current context to an array.  This is what allows the handlebars style traversal, so you can access values from outside of the current context."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"engine"}),(0,s.jsxs)(n.td,{children:["The current engine powering this call, this is really useful for when you're building custom control structures and want to invoke ",(0,s.jsx)(n.code,{children:"engine.run"})," or similar."]})]})]})]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h4,{id:"assisting-the-engine",children:"Assisting the Engine"}),"\n",(0,s.jsxs)(n.p,{children:['It is possible to inform the engine of things it could use to try to optimize itself during "compilation". If your function has no side-effects, you can flag it as deterministic by passing in an additional parameter ',(0,s.jsx)("br",{}),(0,s.jsx)("br",{})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.addMethod('repeat', ([str, times]) => {\n    return str.repeat(times)\n}, { deterministic: true })\n"})}),"\n",(0,s.jsx)(n.p,{children:"This will allow it to evaluate whether the input to this function is also deterministic, and pre-compute the result for the generated function."}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)(n.p,{children:["Alternatively, if you use the advanced object syntax for adding a function, you can make ",(0,s.jsx)(n.code,{children:"determistic"})," a function, this is particularly useful if you've turned off automatic traversal."]}),"\n",(0,s.jsx)("br",{}),"\n",(0,s.jsxs)(n.p,{children:["Additionally, if you are using the ",(0,s.jsx)(n.code,{children:"AsyncLogicEngine"})," class, if a particular function is fully synchronous, you may pass in ",(0,s.jsx)(n.code,{children:"sync: true"})," as an annotation well."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"engine.addMethod('repeat', ([str, times]) => {\n    return str.repeat(times)\n}, { deterministic: true, sync: true })\n"})}),"\n",(0,s.jsx)(n.p,{children:"This will allow the engine to more efficiently compose your custom functions together for optimal-performance."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}}}]);